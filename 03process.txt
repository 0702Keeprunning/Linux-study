0 PCB
    进程只能读写用户空间
    按页管理内存 1page 4096bytes，页可以设置R/W属性
    intel处理器有0-3级别，linux只使用0-内核态-访问内核空间，3-用户态-访问用户空间，通过系统调用来进行切换

    用户态3级 应用程序printf
    sys_write ----------------------- 汇编int 0x80 / ARM swi 软中断
    内核态0级

1 进程环境
    0-3G从上倒下
        环境变量(高地址 env命令)
        命令行参数
        栈
        共享库
        堆
        bss段
        data段
        代码段

2 进程状态
    运行，就绪，睡眠，终止
    CPU组成：运算器，寄存器，控制器，译码器
    汇编：movl eax ebx 操作寄存器

    操作系统完成进程调度 分时复用cpu 1时间片=10ms(10^7ns)
    处理器现场：包含寄存器值，保存到内核空间PCB中的内核栈中
    a.out           b.out
    代码段           代码段

3 进程原语
    fork进程原理
    父进程         子进程
    kernel        kernel
    栈             栈-独立
    text          text
    clone父进程0到3G的内容，pcb拷贝，但是pid没有复制
    fork -> create()进程 clone()复制 return返回
    调用1次，返回2次，父进程返回子进程pid，子进程返回0
    不是完全拷贝，而是建立映射，copy on write

    getuid/getgid
    file设置用户id，执行此文件，执行者变为有效用户id，s

    exec
    a.out代码段覆盖替换掉APP的代码段，不替换内核中的PCB

    wait - 阻塞函数，等待回收子进程资源，如果没有子进程，wait返回-1，一次wait只能回收一个
    return 0后用户空间释放，PCB等待父进程释放(有id号)，没有回收pcb，即为僵尸进程
    目的：让父进程知道子进程是如何死的，通过status来知道
    孤儿进程：父进程先于子进程结束，子进程的父进程成为1号进程init


练习：
    创建多个子进程，并且释放多个子进程
    创建子进程，再创建子进程，依次回收释放












